#!/usr/bin/python2.7
#
# Univention Portal
#
# Copyright 2020 Univention GmbH
#
# https://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <https://www.gnu.org/licenses/>.

import os.path
import json
import datetime

from univention.config_registry import ConfigRegistry

from univention.portal import make_portal
from univention.portal.log import setup_logger, get_logger

import click


portals_json = "/usr/share/univention-portal/portals.json"


def read_portals_json():
    try:
        with open(portals_json) as fd:
            return json.load(fd)
    except EnvironmentError:
        return {}


@click.group()
def cli():
    pass


def make_new_portal(name, portal_cache_file, groups_cache_file, with_portal_reloader, with_groups_reloader, portal_dn):
    cache_dir = "/var/cache/univention-portal/"
    if name:
        cache_dir += name + "/"
    if name:
        scorer = {
            "type": "class",
            "class": "DomainScorer",
            "kwargs": {
                "domain": {
                    "type": "static",
                    "value": name,
                },
            },
        }
    else:
        scorer = {
            "type": "class",
            "class": "Scorer",
        }
    if with_portal_reloader:
        ucr = ConfigRegistry()
        ucr.load()
        portal_reloader = {
            "type": "class",
            "class": "PortalReloaderUDM",
            "kwargs": {
                "portal_dn": {
                    "type": "static",
                    "value": portal_dn or "cn=domain,cn=portal,cn=portals,cn=univention,{}".format(ucr.get("ldap/base")),
                },
                "cache_file": {
                    "type": "static",
                    "value": portal_cache_file or os.path.join(cache_dir, "portal.json"),
                },
            },
        }
    if with_groups_reloader:
        ucr = ConfigRegistry()
        ucr.load()
        groups_reloader = {
            "type": "class",
            "class": "GroupsReloaderLDAP",
            "kwargs": {
                "ldap_uri": {
                    "type": "static",
                    "value": "ldap://{}:{}".format(ucr.get("ldap/server/name"), ucr.get("ldap/server/port")),
                },
                "binddn": {
                    "type": "static",
                    "value": ucr.get("ldap/hostdn"),
                },
                "password_file": {
                    "type": "static",
                    "value": "/etc/machine.secret",
                },
                "ldap_base": {
                    "type": "static",
                    "value": ucr.get("ldap/base"),
                },
                "cache_file": {
                    "type": "static",
                    "value": groups_cache_file or os.path.join(cache_dir, "groups.json"),
                },
            },
        }
    portal_cache = {
        "type": "class",
        "class": "PortalFileCache",
        "kwargs": {
            "cache_file": {
                "type": "static",
                "value": portal_cache_file or os.path.join(cache_dir, "portal.json"),
            },
        }
    }
    groups_cache = {
        "type": "class",
        "class": "GroupFileCache",
        "kwargs": {
            "cache_file": {
                "type": "static",
                "value": groups_cache_file or os.path.join(cache_dir, "groups.json"),
            },
        }
    }
    if with_portal_reloader:
        portal_cache["kwargs"]["reloader"] = portal_reloader
    if with_groups_reloader:
        groups_cache["kwargs"]["reloader"] = groups_reloader
    portal = {
        "type": "class",
        "class": "Portal",
        "kwargs": {
            "portal_cache": portal_cache,
            "groups_cache": groups_cache,
            "scorer": scorer,
        }
    }
    return portal


@cli.command()
@click.argument("name")
@click.option("--update/--dont-update", default=True)
def add(name, update):
    json_content = read_portals_json()
    name = name or "default"
    if name in json_content:
        if update:
            warn("Overwriting existing {}".format(name))
        else:
            info("{} already exists".format(name))
            return
    click.echo("We will now create a new portal object together")
    click.echo("Which class do you want it to be? Possible answers are:")
    from univention.portal import get_all_dynamic_classes
    possible_classes = [klass.__name__ for klass in get_all_dynamic_classes()]
    for klass in possible_classes:
        click.echo("  {}()".format(klass))
    click.echo("  value")
    klass_default = None
    if "Portal" in possible_classes:
        klass_default = "Portal()"
    portal = ask_value(name, klass_default=klass_default)
    click.echo(portal)

def ask_value(name, klass_default=None, value_default=None):
    from univention.portal import get_all_dynamic_classes, get_dynamic_classes
    possible_classes = [klass.__name__ for klass in get_all_dynamic_classes()]
    choice = click.prompt("Choose the value of {}".format(name), default=klass_default,
            type=click.Choice([klass + "()" for klass in possible_classes] + ["value"]))
    if choice == "value":
        pass
    else:
        import inspect
        klass_name = choice[:-2]
        klass = get_dynamic_classes(klass_name)
        click.echo("Okay, got class {}".format(klass_name))
        spec = inspect.getargspec(klass.__init__)
        click.echo("A {} takes {} arguments ({})".format(klass_name, len(spec.args) - 1, ', '.join(repr(arg) for arg in spec.args[1:])))
        kwargs = {}
        if spec.defaults:
            defaults = dict(zip(reversed(spec.args[1:], spec.defaults)))
        else:
            defaults = {}
        for arg in spec.args[1:]:
            klass_default = value_default = None
            default = defaults.get(arg)
            if default is not None:
                klass_default = "value"
                value_default = default
            else:
                if camelcase(arg) in possible_classes:
                    klass_default = camelcase(arg) + "()"
            kwargs[arg] = ask_value(arg, klass_default=klass_default, value_default=value_default)
        click.echo("Okay, {} initialized".format(klass_name))
        return klass(**kwargs)


def capfirst(value):
    if value:
        return value[0].upper() + value[1:]


def camelcase(value):
    if value:
        return ''.join(capfirst(part) for part in value.split('_'))


@cli.command()
@click.argument("name")
@click.option("--purge", default=False)
def remove(name, purge):
    json_content = read_portals_json()
    if not json_content.pop(name, None):
        warn("{} does not exist".format(name))
        return
    ucr = ConfigRegistry()
    ucr.load()
    obj = get_obj(name, ucr)
    if not obj:
        warn("{} does not exist".format(name))
    else:
        rm_localhost(obj, ucr)
        if purge and not any(meta.startswith("server:") for meta in obj.props.meta):
            obj.delete()
            success("Removed unused {} from LDAP")
        else:
            obj.save()
    with open(portals_json, "w") as fd:
        json.dump(json_content, fd, sort_keys=True, indent=4)
    success("{} removed".format(name))


@cli.command("list")
def list_portals():
    json_content = read_portals_json()
    for name, portal_def in json_content.items():
        click.echo("{}:".format(name))
        portal = make_obj(portal_def)
        click.echo("  {!r}".format(portal))


@cli.command()
@click.argument("name")
def push(name):
    from univention.udm import UDM, NoObject
    from univention.udm.encoders import Base64Bzip2BinaryProperty
    json_content = read_portals_json()
    if name not in json_content:
        warn("{} does not exist".format(name))
        return
    portal_def = json_content[name]
    udm = UDM.machine().version(1)
    data = udm.get("settings/data")
    ucr = ConfigRegistry()
    ucr.load()
    base = "cn=config,cn=portals,cn=univention,{}".format(ucr.get("ldap/base"))
    try:
        obj = data.get("cn={},{}".format(name, base))
    except NoObject:
        obj = data.new(superordinate="cn=univention,{}".format(ucr.get("ldap/base")))
        obj.position = base
        obj.props.name = name
        obj.props.data_type = "portals/config"
        info("Creating a new settings/data object")
    json_data = json.dumps(portal_def)
    obj.props.data = Base64Bzip2BinaryProperty("data", raw_value=json_data)
    add_localhost(obj, ucr)
    obj.save()
    success("Saved {} in {}".format(name, obj.dn))


@cli.command()
@click.argument("name")
def pull(name):
    ucr = ConfigRegistry()
    ucr.load()
    obj = get_obj(name, ucr)
    if not obj:
        warn("{} does not exist".format(name))
        return
    json_data = json.loads(obj.props.data.raw)
    json_content = read_portals_json()
    json_content[name] = json_data
    with open(portals_json, "w") as fd:
        json.dump(json_content, fd, sort_keys=True, indent=4)
    success("{} updated".format(portals_json))
    if add_localhost(obj, ucr):
        obj.save()
        success("{} updated".format(obj.dn))

def get_obj(name, ucr):
    from univention.udm import UDM, NoObject
    udm = UDM.machine().version(1)
    data = udm.get("settings/data")
    base = "cn=config,cn=portals,cn=univention,{}".format(ucr.get("ldap/base"))
    dn = "cn={},{}".format(name, base)
    try:
        return data.get(dn)
    except NoObject:
        return None

def add_localhost(obj, ucr):
    localhost = "{}.{}".format(ucr.get("hostname"), ucr.get("domainname"))
    server_key = "server:{}".format(localhost)
    if server_key not in obj.props.meta:
        obj.props.meta.append(server_key)
        return True

def rm_localhost(obj, ucr):
    localhost = "{}.{}".format(ucr.get("hostname"), ucr.get("domainname"))
    server_key = "server:{}".format(localhost)
    if server_key in obj.props.meta:
        obj.props.meta.remove(server_key)
        return True

@cli.command()
@click.argument("name", nargs=-1)
def update(name, portal, groups):
    json_content = read_portals_json()
    if not name:
        name = json_content.keys()
    for _name in name:
        info("Updating {}".format(_name))
        try:
            portal_def = json_content[_name]
        except KeyError:
            warn("{} does not exist".format(name))
        else:
            portal_obj = make_portal(portal_def)
            start = datetime.datetime.now()
            if portal_obj.refresh():
                delta = datetime.datetime.now() - start
                success("Portal data updated in {:.2f}s".format(delta.total_seconds()))
            else:
                info("Portal data untouched")


class SomeObj(object):
    def __init__(self, klass_name, args, kwargs):
        self.klass_name = klass_name
        self.args = args
        self.kwargs = kwargs

    def all_args(self):
        ret = []
        for arg in self.args:
            ret.append(repr(arg))
        for name, arg in self.kwargs.items():
            ret.append("{}={!r}".format(name, arg))
        return ", ".join(ret)

    def __repr__(self):
        return "{}({})".format(self.klass_name, self.all_args())


def make_obj(obj_def):
    arg_type = obj_def["type"]
    if arg_type == "static":
        return obj_def["value"]
    if arg_type == "class":
        args = []
        kwargs = {}
        for _arg_definition in obj_def.get("args", []):
            args.append(make_obj(_arg_definition))
        for name, _arg_definition in obj_def.get("kwargs", {}).items():
            kwargs[name] = make_obj(_arg_definition)
        return SomeObj(obj_def["class"], args, kwargs)
    raise TypeError("Unknown obj_def: {!r}".format(obj_def))

def warn(msg):
    get_logger("cli").warn(msg)
    click.echo(click.style(msg, fg="yellow"))

def info(msg):
    get_logger("cli").info(msg)
    click.echo(msg)

def success(msg):
    get_logger("cli").info(msg)
    click.echo(click.style(msg, fg="green"))

if __name__ == "__main__":
    setup_logger(stream=False)
    cli()
