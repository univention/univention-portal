#!/usr/bin/python2.7
#
# Univention Portal
#
# Copyright 2019-2020 Univention GmbH
#
# https://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <https://www.gnu.org/licenses/>.

import json
import grp
import sys
import os
import os.path
import shutil
from imghdr import what
from StringIO import StringIO
from copy import deepcopy
import tempfile
import logging
import signal
from urllib import quote

import requests
import tornado.ioloop
import tornado.web
import ldap

from univention.udm import UDM, UnknownModuleType
import univention.admin.uexceptions as uexceptions
from univention.config_registry import ConfigRegistry
from univention.udm.modules.portal import PortalsPortalEntryObject, PortalsPortalFolderObject
from univention.config_registry.handler import run_filter

ucr = ConfigRegistry()
ucr.load()

LOG_FILE = '/var/log/univention/portal.log'
UMC_SESSION_URL = 'http://localhost/univention/get/session-info'


class NoPortalDefined(Exception):
	pass


class ShortNameFormatter(logging.Formatter):
	shorten = 'univention.portal'

	def format(self, record):
		record.short_name = record.name
		if record.short_name.startswith('%s.' % self.shorten):
			record.short_name = record.short_name[len(self.shorten) + 1:]
		return super(ShortNameFormatter, self).format(record)


def setup_logger():
	logger = logging.getLogger('univention.portal')
	log_format = '%(process)6d %(short_name)-12s %(asctime)s [%(levelname)8s]: ' \
		'%(message)s'
	log_format_time = '%y-%m-%d %H:%M:%S'
	formatter = ShortNameFormatter(log_format, log_format_time)
	handler = logging.FileHandler(LOG_FILE)
	handler.setFormatter(formatter)
	logger.addHandler(handler)
	handler = logging.StreamHandler(sys.stdout)
	logger.addHandler(handler)
	logger.setLevel(logging.DEBUG)


def get_logger(name):
	logger = logging.getLogger('univention.portal')
	logger = logger.getChild(name)
	return logger


def flatten(list_of_lists):
	# return [item for sublist in list_of_lists for item in sublist]
	# => does not work well for strings in list
	ret = []
	for sublist in list_of_lists:
		if isinstance(sublist, (list, tuple)):
			ret.extend(flatten(sublist))
		else:
			ret.append(sublist)
	return ret


class LDAPCache(object):
	PORTAL_CACHE = '/var/cache/univention-portal/portal.json'
	FALLBACK_PORTAL_CACHE = '/usr/share/univention-portal/portal-unjoined.json'
	GROUP_CACHE = '/var/cache/univention-portal/groups.json'
	REFRESH_PORTAL_FILE = '/var/cache/univention-portal/refresh_portal'
	REFRESH_GROUP_FILE = '/var/cache/univention-portal/refresh_groups'

	def __init__(self):
		self._cache = None
		self._groups = None
		self._udm = None

	@property
	def udm(self):
		if self._udm is None:
			self._udm = UDM.machine().version(2)
		return self._udm

	def _get_groups(self):
		if self._groups is None or os.path.exists(self.REFRESH_GROUP_FILE):
			get_logger('cache').info('loading group cache file')
			try:
				with open(self.GROUP_CACHE) as fd:
					self._groups = json.load(fd)
			except EnvironmentError:
				get_logger('cache').warn('unable to read group cache file')
				self._groups = None
			except ValueError:
				get_logger('cache').exception('unable to read group cache file')
				self._groups = None
			if os.path.exists(self.REFRESH_GROUP_FILE):
				os.unlink(self.REFRESH_GROUP_FILE)
		return self._groups

	def load(self, fallback=False):
		get_logger('cache').info('loading cache file')
		try:
			with open(self.PORTAL_CACHE) as fd:
				self._cache = json.load(fd)
		except EnvironmentError:  # TODO: catch ValueError?!
			if fallback:
				get_logger('cache').warn('falling back to %s!' % self.FALLBACK_PORTAL_CACHE)
				with open(self.FALLBACK_PORTAL_CACHE) as fd:
					content = fd.read()
					content = run_filter(content, ucr)
					self._cache = json.loads(content)
			else:
				raise

	def get(self, name):
		if name == 'groups':
			return self._get_groups() or {}
		else:
			return self._get_portal(name)

	def _get_portal(self, name):
		if os.path.exists(self.REFRESH_PORTAL_FILE):
			self.refresh()
			try:
				os.unlink(self.REFRESH_PORTAL_FILE)
			except EnvironmentError:
				pass
			self._cache = None
		if self._cache is None:
			try:
				self.load()
			except EnvironmentError:
				self.refresh()
				self.load(fallback=True)
		get_logger('cache').debug('getting %s from cache' % name)
		return deepcopy(self._cache[name])

	def refresh(self):
		ucr.load()
		get_logger('cache').info('refreshing cache')
		fd = None
		try:
			try:
				fd = self._refresh()
			except (ldap.SERVER_DOWN, ldap.INSUFFICIENT_ACCESS, ldap.INVALID_CREDENTIALS, uexceptions.ldapError):
				get_logger('server').info('Reconnecting ldap connection')
				self._udm = None
				fd = self._refresh()
		except NoPortalDefined as exc:
			# this may happen during system-setup when portals/portal et al are
			# not yet created or not yet linked to localhost but someone said
			# service univention-portal-server reload (i.e. our listener modules)
			get_logger('cache').warn('It seems your server has not yet defined a portal object. Assign %s to any one portals/portal object via UDM. You may need to restart this service.', exc)
			# hopefully, we can still work with an older cache?
		except UnknownModuleType:
			# this may happen during system-setup when portals/portal et al are
			# not yet registered via ucs_registerLDAPExtension but someone said
			# service univention-portal-server reload (i.e. our listener modules)
			get_logger('cache').warn('It seems the portals/* UDM modules are not yet ready. Check the join status. You may need to restart this service.')
			# hopefully, we can still work with an older cache?
		except Exception:
			get_logger('cache').exception('Error during refresh')
			# hopefully, we can still work with an older cache?
		else:
			if fd:
				shutil.move(fd.name, self.PORTAL_CACHE)

	def _refresh(self):
		ldap_hostdn = ucr.get('ldap/hostdn')
		for portal in self.udm.get('portals/portal').search():
			if ldap_hostdn in portal.props.portalComputers:
				break
		else:
			raise NoPortalDefined(ldap_hostdn)  # default portal?
			portal = self.udm.get('portals/portal').get('')
		content = {}
		content['portal'] = self._extract_portal(portal)
		content['user_links'] = self._extract_user_links(portal)
		content['menu_links'] = self._extract_menu_links(portal)
		content['categories'] = self._extract_categories(portal)
		content['entries'] = self._extract_entries(portal)
		content['folders'] = self._extract_folders(portal)
		with tempfile.NamedTemporaryFile(delete=False) as fd:
			json.dump(content, fd, sort_keys=True, indent=4)
		return fd

	def _extract_portal(self, portal):
		#  self._write_css(portal)
		ret = {}
		ret['dn'] = portal.dn
		ret['showApps'] = portal.props.showApps
		ret['fontColor'] = portal.props.fontColor
		if portal.props.logo:
			ret['logo'] = self._write_image(portal.props.name, portal.props.logo.raw, 'logos')
		else:
			ret['logo'] = None
		ret['background'] = (
			self._write_image(portal.props.name, portal.props.background.raw, 'backgrounds')
			if portal.props.background
			else None
		)
		ret['name'] = portal.props.displayName
		ret['ensureLogin'] = portal.props.ensureLogin
		ret['anonymousEmpty'] = portal.props.anonymousEmpty
		ret['autoLayoutCategories'] = portal.props.autoLayoutCategories
		ret['defaultLinkTarget'] = portal.props.defaultLinkTarget
		ret['categories'] = portal.props.categories
		return ret

	def _extract_user_links(self, portal):
		ret = []
		for (idx, entry) in enumerate(portal.props.userLinks.objs):
			ret.append({
				'dn': entry.dn,
				'name': entry.props.displayName,
				'description': entry.props.description,
				'logo_name': self._save_image(portal, entry),
				'activated': entry.props.activated,
				'anonymous': entry.props.anonymous,
				'allowedGroups': entry.props.allowedGroups,
				'links': entry.props.link,
				'linkTarget': entry.props.linkTarget,
				'$priority': idx,
			})
		return ret

	def _extract_menu_links(self, portal):
		ret = []
		for (idx, entry) in enumerate(portal.props.menuLinks.objs):
			ret.append({
				'dn': entry.dn,
				'name': entry.props.displayName,
				'description': entry.props.description,
				'logo_name': self._save_image(portal, entry),
				'activated': entry.props.activated,
				'anonymous': entry.props.anonymous,
				'allowedGroups': entry.props.allowedGroups,
				'links': entry.props.link,
				'linkTarget': entry.props.linkTarget,
				'$priority': idx,
				# this is supposed to be the (ordered) idx of the unfiltered (no removed links due to allowdGroups etc)
				# portal.props.menuLinks, so that the frontend can display the menu links in the correct e.g.:
				# menuLinks = [
				#	{dn: A, allowdGroups: foo, $priority: 0},
				#	{dn: B,                    $priority: 1},
				# ]
				# visiting portal anonymously -> menu link B is rendered
				# user of group 'foo' logs in -> menu link A is rendered above B
			})
		return ret

	def _extract_categories(self, portal):
		ret = {}
		for category in portal.props.categories.objs:
			ret[category.dn] = {
				'dn': category.dn,
				'display_name': category.props.displayName,
				'entries': category.props.entries,
			}
		return ret

	def _extract_entries(self, portal):
		def _add(entry, ret):
			if entry.dn not in ret:
				ret[entry.dn] = {
					'dn': entry.dn,
					'name': entry.props.displayName,
					'description': entry.props.description,
					'logo_name': self._save_image(portal, entry),
					'activated': entry.props.activated,
					'anonymous': entry.props.anonymous,
					'allowedGroups': entry.props.allowedGroups,
					'links': entry.props.link,
					'linkTarget': entry.props.linkTarget,
					'backgroundColor': entry.props.backgroundColor,
				}

		def _add_entry(entry, ret, already_unpacked_folder_dns):
			if isinstance(entry, PortalsPortalFolderObject):
				if entry.dn not in already_unpacked_folder_dns:
					already_unpacked_folder_dns.append(entry.dn)
					for entry in entry.props.entries.objs:
						_add_entry(entry, ret, already_unpacked_folder_dns)
			elif isinstance(entry, PortalsPortalEntryObject):
				_add(entry, ret)
			else:
				pass  # TODO raise error?

		ret = {}
		already_unpacked_folder_dns = []
		for category in portal.props.categories.objs:
			for entry in category.props.entries.objs:
				_add_entry(entry, ret, already_unpacked_folder_dns)
		return ret

	def _extract_folders(self, portal):
		def _add(entry, ret):
			if entry.dn not in ret:
				ret[entry.dn] = {
					'dn': entry.dn,
					'name': entry.props.displayName,
					'entries': entry.props.entries,
				}

		def _add_entry(entry, ret, already_unpacked_folder_dns):
			if isinstance(entry, PortalsPortalFolderObject):
				if entry.dn not in already_unpacked_folder_dns:
					already_unpacked_folder_dns.append(entry.dn)
					_add(entry, ret)
					for entry in entry.props.entries.objs:
						_add_entry(entry, ret, already_unpacked_folder_dns)

		ret = {}
		already_unpacked_folder_dns = []
		for category in portal.props.categories.objs:
			for entry in category.props.entries.objs:
				_add_entry(entry, ret, already_unpacked_folder_dns)
		return ret

	def _write_css(self, portal):
		# get CSS rule for body background
		background = []
		image = portal.props.background
		bg_img = None
		if image:
			get_logger('css').info('Writing background image')
			bg_img = self._write_image(portal.props.name, image.raw, 'backgrounds')
		if bg_img:
			background.append('url("%s") no-repeat top center / cover' % (bg_img, ))
		css = portal.props.cssBackground
		if css:
			get_logger('css').info('Adding background CSS')
			background.append(css)
		background = ', '.join(background)

		# get font color
		font_color = portal.props.fontColor

		# prepare CSS code
		css_code = ''
		if background:
			css_code += '''
	body.umc.portal {
		background: %s;
	}
	''' % (background, )

		if font_color == 'white':
			get_logger('css').info('Adding White Header')
			css_code += '''
	body.umc.portal .umcHeader .umcHeaderLeft h1 {
		color: white;
	}

	body.umc.portal .portalCategory h2 {
		color: white;
	}
	'''

		get_logger('css').info('No CSS code available')
		if not css_code:
			css_code = '/* no styling defined via UDM portal object */\n'

		# write CSS file
		fname = '/var/www/univention/portal/portal.css'
		get_logger('css').info('Writing CSS file %s' % fname)
		try:
			with open(fname, 'wb') as fd:
				fd.write(css_code)
		except (EnvironmentError, IOError) as err:
			get_logger('css').warn('Failed to write CSS file %s: %s' % (fname, err))

	def _write_image(self, name, img, dirname):
		try:
			name = name.replace('/', '-')  # name must not contain / and must be a path which can be accessed via the web!
			string_buffer = StringIO(img)
			suffix = what(string_buffer) or 'svg'
			fname = '/usr/share/univention-portal/icons/%s/%s.%s' % (dirname, name, suffix)
			with open(fname, 'wb') as fd:
				fd.write(img)
		except (EnvironmentError, TypeError, IOError) as err:
			get_logger('css').error(err)
		else:
			return '/univention/portal/icons/%s/%s.%s' % (quote(dirname), quote(name), quote(suffix))

	def _save_image(self, portal, entry):
		img = entry.props.icon
		if img:
			return self._write_image(entry.props.name, img.raw, 'entries')


class JsonHandler(tornado.web.RequestHandler):
	def _recursive_search_in_groups(self, username, group, groups, checked_groups):
		if username is None:
			return False
		if username in group['usernames']:
			return True
		for group_dn in group['groups']:
			if group_dn in checked_groups:
				continue
			group = groups.get(group_dn)
			if group is None:
				continue
			checked_groups.append(group_dn)
			if self._recursive_search_in_groups(username, group, groups, checked_groups):
				return True
		return False

	def _get_portal(self, categories, visible_content):
		portal = cache.get('portal')
		portal['categories'] = [category_dn for category_dn in portal['categories'] if category_dn in visible_content['category_dns']]
		portal['content'] = [
			[category_dn, categories[category_dn]['entries']]
			for category_dn in portal['categories']
		]
		return portal

	def _get_all_entries_of_folder(self, folder_dn, folders, entries):
		def _flatten(folder_dn, folders, entries, ret, already_unpacked_folder_dns):
			for entry_dn in folders[folder_dn]['entries']:
				if entry_dn in entries:
					if entry_dn not in ret:
						ret.append(entry_dn)
				elif entry_dn in folders:
					if entry_dn not in already_unpacked_folder_dns:
						already_unpacked_folder_dns.append(entry_dn)
						_flatten(entry_dn, folders, entries, ret, already_unpacked_folder_dns)

		ret = []
		_flatten(folder_dn, folders, entries, ret, [])
		return ret

	def _filter_entry_dns(self, entry_dns, entries, username, admin_mode):
		groups = cache.get('groups')
		filtered_dns = []
		for entry_dn in entry_dns:
			entry = entries.get(entry_dn)
			if entry is None:
				continue
			if not admin_mode:
				if not entry['activated']:
					continue
				if not entry['anonymous'] and username:
					continue
				if entry['allowedGroups']:
					checked_groups = []
					for group_dn in entry['allowedGroups']:
						group = groups.get(group_dn)
						if group is None:
							continue
						if self._recursive_search_in_groups(username, group, groups, checked_groups):
							break
					else:
						continue
			filtered_dns.append(entry_dn)
		return filtered_dns

	def _get_user_links(self, username, admin_mode):
		if username is None:
			return []
		links = cache.get('user_links')
		links_dict = dict((link['dn'], link) for link in links)
		entry_dns = [link['dn'] for link in links]
		return [links_dict[dn] for dn in self._filter_entry_dns(entry_dns, links_dict, username, admin_mode)]

	def _get_menu_links(self, username, admin_mode):
		links = cache.get('menu_links')
		links_dict = dict((link['dn'], link) for link in links)
		entry_dns = [link['dn'] for link in links]
		return [links_dict[dn] for dn in self._filter_entry_dns(entry_dns, links_dict, username, admin_mode)]

	def _get_categories(self, visible_content):
		categories = cache.get('categories')
		categories = {category_dn: categories[category_dn] for category_dn in visible_content['category_dns']}
		for category in categories.values():
			category['entries'] = [
				entry_dn for entry_dn in category['entries']
				if entry_dn in visible_content['entry_dns'] or entry_dn in visible_content['folder_dns']
			]
		return categories

	def _get_folders(self, visible_content):
		folders = cache.get('folders')
		folders = {folder_dn: folders[folder_dn] for folder_dn in visible_content['folder_dns']}
		for folder in folders.values():
			folder['entries'] = [
				entry_dn for entry_dn in folder['entries']
				if entry_dn in visible_content['entry_dns'] or entry_dn in visible_content['folder_dns']
			]
		return folders

	def _get_entries(self, visible_content):
		entries = cache.get('entries')
		return {entry_dn: entries[entry_dn] for entry_dn in visible_content['entry_dns']}

	def _ask_umc(self, cookies):
		try:
			response = requests.get(UMC_SESSION_URL, cookies=cookies)
			data = response.json()
			username = data['result']['username']
		except requests.ConnectionError as exc:
			get_logger('user').error('connection failed: %s' % exc)
		except ValueError:
			get_logger('user').error('malformed answer: %s' % (response.text,))
		except KeyError:
			get_logger('user').warn('session unknown!')
		else:
			return username

	def _get_username(self, cookies):
		if not any(cookie.startswith('UMCSessionId') for cookie in cookies):
			get_logger('user').debug('no user given')
			return None
		get_logger('user').debug('searching user for cookies=%r' % (cookies,))
		username = self._ask_umc(cookies)
		if username is None:
			get_logger('user').debug('no user found')
		else:
			get_logger('user').debug('found %s' % username)
			return username.lower()

	def write_error(self, status_code, **kwargs):
		if 'exc_info' in kwargs:
			get_logger('server').exception('Error during service')
		return super(JsonHandler, self).write_error(status_code, **kwargs)

	def log_exception(self, typ, value, tb):
		if isinstance(value, (ldap.SERVER_DOWN, ldap.INSUFFICIENT_ACCESS, ldap.INVALID_CREDENTIALS, uexceptions.ldapError)):
			get_logger('server').info('Reconnecting ldap connection')
			cache._udm = None
		return super(JsonHandler, self).log_exception(typ, value, tb)

	def _get_visible_content(self, username, admin_mode):
		entries = cache.get('entries')
		folders = cache.get('folders')
		categories = cache.get('categories')
		visible_entry_dns = self._filter_entry_dns(entries.keys(), entries, username, admin_mode)
		visible_folder_dns = [
			folder_dn for folder_dn in folders.keys()
			if admin_mode or len(
				[
					entry_dn for entry_dn in self._get_all_entries_of_folder(folder_dn, folders, entries)
					if entry_dn in visible_entry_dns
				]
			) > 0
		]
		visible_category_dns = [
			category_dn for category_dn in categories.keys()
			if admin_mode or len(
				[
					entry_dn for entry_dn in categories[category_dn]['entries']
					if entry_dn in visible_entry_dns or entry_dn in visible_folder_dns
				]
			) > 0
		]
		return {
			'entry_dns': visible_entry_dns,
			'folder_dns': visible_folder_dns,
			'category_dns': visible_category_dns,
		}

	def get(self):
		cookies = dict((key, morsel.value) for key, morsel in self.cookies.items())
		username = self._get_username(cookies)
		admin_mode = False
		if self.request.headers.get('X-Univention-Portal-Admin-Mode', 'no') == 'yes':
			get_logger('admin').info('Admin mode requested')
			admin_group_name = ucr.get('groups/default/domainadmins', 'Domain Admins')
			admins = [admin.lower() for admin in grp.getgrnam(admin_group_name)[3]]
			admin_mode = username in admins
			if admin_mode:
				get_logger('admin').info('Admin mode granted')
			else:
				get_logger('admin').info('Admin mode rejected')
		answer = {}

		visible_content = self._get_visible_content(username, admin_mode)
		answer['user_links'] = self._get_user_links(username, admin_mode)
		answer['menu_links'] = self._get_menu_links(username, admin_mode)
		answer['entries'] = self._get_entries(visible_content)
		answer['folders'] = self._get_folders(visible_content)
		answer['categories'] = self._get_categories(visible_content)
		answer['portal'] = self._get_portal(answer['categories'], visible_content)
		answer['filtered'] = not admin_mode
		self.write(answer)


cache = LDAPCache()


def signal_handler_reload(signo, frame):
	io_loop = tornado.ioloop.IOLoop.instance()
	io_loop.add_callback_from_signal(cache.refresh)


def make_app():
	return tornado.web.Application([
		(r'/', JsonHandler),
	])


if __name__ == "__main__":
	setup_logger()
	app = make_app()
	port = int(ucr.get('portal/port', 8095))
	get_logger('server').info('firing up portal server at port %s' % port)
	app.listen(port)
	signal.signal(signal.SIGHUP, signal_handler_reload)
	tornado.ioloop.IOLoop.current().start()
